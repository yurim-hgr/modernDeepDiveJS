# 13장 스코프

### 렉시컬 환경

- 코드가 어디서 실행되며 주변에 어떤 코드가 있는지
- 스코프라는 개념이 없다면 같은 이름을 갖는 변수는 충돌을 일으키므로 프로그램 전체에서 하나밖에 사용할수없다.

### 스코프

- 식별자를 검색하는 규칙
  var 는 함수의 코드블록만 지역스코프로 인정

### 함수상위스코프

- 자바스크립트는 렉시컬 스코프를 따르므로 어디서 호출이아니라 함수를 어디서 정의했는지에 따라 상위스코프를 결정한다.
- 함수의 상위스코프는 언제나 자신이 정의된 스코프다.

# 14장 전역변수의 문제점

- 변수선언은 선언문이 어디에 있든 상관없이 가장먼저 실행된다.

### 전역변수 변수선언

변수선언은 코드가 한 줄 씩 순차적으로 실행되는 시점인 런타임에 실행되는 것이 아니라 런타임 이전 단계에서 자바스크립트 엔진에 의해 먼저 실행된다.

### 함수내부에서 변수선언

함수 내부에서 선언한 변수는 함수가 호출된 직후에 함수 몸체의 코드가 한줄씩 순자적으로 실행되기 이전에 자바스크립트 엔진에 의해 먼저 실행된다.

지역변수의 생명주기는 함수의 생명주기와 같다.

하지만 누군가가 스코프를 참조하고 있다면 스코프는 해제되지 않고 생존하게된다.

## 문제점

- 암묵적 결합
  모든코드가 전역변수를 참조하고 변경
- 긴생명주기
- 스코프체인상에서 종점에 존제
- 네임스페이스 오염

## 억제방법

- 변수의 스코프는 좁을수록 좋다.

- 모듈패턴
- 캡슐화는 객체의 상태를 나타내는 프로퍼티와프로퍼티를참조하고 조작할수있는 동작인메서드를 하나로 묶는 것을 말한다.
  캡슐화 : 객체의 특정프로퍼티나 메서드를감출 목적으로 사용하기도 하는데 이를정보 은닉이라고도한다.

### ES6모듈

- ES6 모듈을 사용하면 더는 전역 변수를 사용할수 없다.
- ES6 모듈은 파일 자체의 독자적인모듈 스코프를 제공한다.

# 15장 let, const 키워드와 블록 레벨 스코프

## var 의 문제점

1. 변수중복선언 허용
   이미 선언되어있는것을 모르고 변수를 중복선언 하면서 값까지 할당했다면 의도치않게먼저 선언된변수값이 변경되는부작용이 발생한다.
2. 함수레벨 스코프
   오로지 함수의 코드블록 만을지역스코프로 인정
3. 변수 호이스팅
   변수호이스팅에 의해 var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다. 할당문 이전에 변수를 참조하면 undefined 를반환하다.

## let 키워드

1. 변수 중복선언 금지
   중복선언하면 문법에러(syntaxError )
2. 블록레벨스코프
   모든 코드블록 인정
3. 변수 호이스팅
   변수 선언문 이전에 참조하면 참조에러(ReferenceError) 발생
   var 는 선언단계와 초기화단계가 같이 진행 undefined
   let 은 분리되어 진행 자바스크립트엔진에 의해서 암묵적으로 선언단계가 먼저 실행되지만
   초기화단계는 변수선언문에 도달했을때 실행

\*\* 초기화하면 undefined !!

## const 키워드

1. 선언과 초기화
   const 키워드로선언한변수는 반드시 선언과 동시에 초기화해야한다.
   그렇지않으면 SyntaxError
2. 재할당금지
3. 상수
   객체는 프로퍼티동적생성,삭제, 프로퍼티값변경

### 권장

- var 키워드 사용 금지
- 재할당 필요한 경우에 한정해서 let 쓴다. 스코프는 최대한 좁게 만든다.
- 변경이 발생하지않고 읽기전용으로 사용하는 원시값과 객체에는 const 키워드를 사용한다. 재할당을 금지하므로 var, let 보다 안전

⇒ 변수선언하는 시점에는재할당이 필요한지 모르는 경우가 많다.
객체는 의외로 재할당하는 경우가 드물다.
변수를 선언할때는 일단const 키워드를 사용하다 재할당이 필요하다면 그때 변경해도 늦지않다.

# 16장 프로퍼티 어트리뷰트

## 내부 슬롯과 내부 메서드

- 모든 객체는 [[Prototype]] 이라는 내부스롯을 갖는다.
- 내부슬롯은 자바스크립트엔진의 내부 로직이므로 원칙적으로 직접 접근할수는 없지만 [[Prototype]] 내부슬롯의 경우 , **proto** 를 통해 간접적으로 접근할 수 있다.

## 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

- 자바스크립트엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동정의한다.
- Object.getOwnPropertyDescriptor 메서드를 사용하여 간접적으로 확인가능
- 객체 참조 , 키 로 호출하면 프로퍼티 디스크립터 객체들을반환한다.

## 데이터프로퍼티와 접근자프로퍼티

### 데이터 프로퍼티

value , writable, enumerable, configurable

### 접근자 프로퍼티

값을 저장하면 setter 함수가 호출된다.

프로퍼티에 접근하면 getter 함수가 호출된다.

## 프로토타입

어떤 객체의 상위 (부모) 객체의 역할을 하는 객체다 . 프로토 타입은 하위(자식)객체에게 자신의 프로퍼티와 메서드를 상속한다.

Object.defineProperty 메서드

프로퍼티의 어트리뷰트를 정의할수 있다.

# 17장: 생성자 함수에 의한 객체 생성

### **객체 리터럴로 생성시 문제점**

똑같은 여러 객체를 만들경우 코드가 중복되며 비효율적이다.

### **this**

this는 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이다.

| 함수 호출 방식       | this가 가리키는 값(바인딩)    |
| -------------------- | ----------------------------- |
| 일반 함수로 호출     | 전역객체                      |
| 메서드로서 호출      | 메서드를 호출한 객체          |
| 생성자 함수로서 호출 | 생성자 함수가 생성할 인스턴스 |

```jsx
function Circle(radius){
  console.log(this); // Circle ()
  ...
}
```

# 18장 함수와 일급객체

## \***\*함수객체의 프로퍼티\*\***

### length 프로퍼티

- arguments객체의 length프로퍼티는 인수의 개수를 가리키고, 함수객체의 length프로퍼티는 매개변수의 개수를 가리킨다.

## **proto** 접근자 프로퍼티

- [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티.(간접적으로 접근)

## prototype 프로퍼티

- 생성자 함수로 호출할 수 있는 함수 객체, 즉 constructor만이 소유하는 프로퍼티.
- 일반 객체와 생성자 함수로 호출할 수 없는 non-constructor에는 prototype 프로퍼티 없음.

### 중요키워드

1. 프로퍼티 디스크립트 객체
   Object.getOwnPropertyDescriptor
2. var , let , const 키워드
